### 概要

- **目的**: TCP を使ってクライアントから MP4 ファイルをアップロードさせるシンプルなサーバと CLI クライアントを実装するための詳細なコメント設計。実装は Python 推奨。  
- **前提**: ファイルは MP4 のみサポート。送信前にクライアント側で拡張子と MIME を確認すること。ファイルサイズは最大 4GB。パケット送信は 1400 バイト単位で行う。サーバは 32 バイトヘッダ受信後にファイル本体を受け取る。レスポンスは 16 バイトで返す。

### サーバ側設計コメント

- **インポートと初期化**
  - 必要モジュール: `socket`, `threading`, `os`, `time
  - CLI 引数で待ち受けポートと保存ディレクトリ、最大保存容量を指定可能にする
import socket
import threating
import os
import time

- **定数**
  - `LISTEN_ADDR = '0.0.0.0'`
  - `DEFAULT_PORT` を CLI で指定
  - `HEADER_SIZE = 32`  # 最初に受け取るファイルサイズ情報のバイト数
  - `RESPONSE_SIZE = 16`  # サーバからクライアントへ返すステータスメッセージ長
  - `CHUNK_SIZE = 1400`  # TCP 送信で使用する読み書き単位
  - `MAX_FILE_BYTES = 2**32 - 1`  # 4GB 未満
  - `STORAGE_LIMIT_BYTES` を設定して合計保存容量を管理

- **ソケット作成とバインド**
  - TCP ソケットを作成し `setsockopt(SOL_SOCKET, SO_REUSEADDR, 1)` を設定
  - `bind((LISTEN_ADDR, port))` と `listen(backlog)` を呼ぶ
  - シグナルハンドラでグレースフルシャットダウンを実装

- **接続ハンドリング**
  - `accept()` で接続を受け入れたら、**各接続を専用スレッド**で処理する
  - スレッドはタイムアウトを設定し、長時間の停滞を検出して接続を切る

- **受信プロトコル処理**
  - まず `recv_exact(conn, HEADER_SIZE)` のようなヘルパーで 32 バイトを確実に読み取る
  - ヘッダのフォーマットは明確に定義しておく（例: 先頭 8 バイトはファイルサイズの 64 ビット整数、残りは将来拡張用のメタデータ）
  - ヘッダから `file_size` を抽出し、`file_size` が 0 または `> MAX_FILE_BYTES` の場合はエラー応答を返して接続を閉じる
  - 保存先ディレクトリの空き容量と `STORAGE_LIMIT_BYTES` をチェックし、容量不足ならエラー応答

- **ファイル受信と原子保存**
  - 一時ファイル名で受信を行い、全データ受信が成功したら `os.replace()` で最終ファイル名に移動して原子性を確保
  - 受信は `while received < file_size: chunk = conn.recv(min(CHUNK_SIZE, file_size - received))` のループで行う
  - 受信中に例外や接続切断が発生したら一時ファイルを削除してクリーンアップ

- **レスポンス送信**
  - 処理結果を 16 バイトの固定長レスポンスで返す。フォーマット例: 先頭 1 バイトはステータスコード、残りはメッセージやエラーコードのバイナリ表現
  - 成功時はステータス 0、失敗時は非ゼロコードを返す
  - レスポンス送信後にソケットをクローズ

- **並列性とリソース管理**
  - スレッドプールを使うか、接続ごとにスレッドを生成するかを選択。大量接続を想定するなら `concurrent.futures.ThreadPoolExecutor` を推奨
  - 同時保存ファイル数や合計ストレージ使用量に上限を設け、超過時は新規接続を拒否する

- **ログと監視**
  - 受信開始・完了・エラー・容量不足・シャットダウンなどを詳細にログ出力
  - 必要なら簡易メトリクス（受信バイト数、成功数、失敗数）を定期出力

